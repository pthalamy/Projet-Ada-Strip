\documentclass{article}

\usepackage[latin1]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{graphicx}
\usepackage{listings}
\usepackage[usenames, dvipsnames]{color}
\usepackage{framed}

\title{Rapport de Projet Algo -- Strip Packing}
\author{\textsc{Benjamin Lebit} - \textsc{Pierre Thalamy}}
\date{\today}

\begin{document}

\maketitle

<<<<<<< HEAD
\section {Modélisation des objets}
Le type \textit{Objet} représente un rectangle à placer sur la bande. 
Afin de le modéliser, nous avons crée un \textit{record type} contenant 
les attributs suivants:
\begin{itemize}
  \item Indice : Représente l'indice de l'objet comme present dans le fichier 
    parsé.
  \item Largeur : Largeur du rectangle
  \item Hauteur : Hauteur du rectangle
  \item Position : De type \textit{Point}, aussi un \textit{record type} comprenant une 
    coordonné X et une Y. 
    Représente la position du coin supérieur gauche du rectangle dans le graph SVG.
\end{itemize}

Comme le type \textit{Objet} est declaré comme \textit{private}, nous avons crée tout un jeu de \textit{Setters} et \textit{Getters} pour lire ou modifier la valeur de ses attributs.
Finalement, \textit{Tableau\_Objets} est un tableau non-contraint d'éléments de type Objet.

\section {Parseur}
Le fonctionnement du \textit{Parseur} est simple, \textbf{Lecture\_En\_Tete} se contente de lire les deux premiers nombres de type \textit{Natural} qu'il trouve dans le fichier d'entré. \\
La procedure \textbf{Lecture} quand à elle saute les deux premieres lignes du fichier, puis pour tous les objets du fichier, lit sa valeur d'indice, sa largeur, et sa hauteur, et les stocke dans les attributs de l'\textit{Objet} correspondant à l'intérieur du tableau d'\textit{Objets}.
\paragraph{} Dans les deux cas, nous avons fait attention à bien gérer toutes les exceptions qu'il est possible de rencontrer lors de la lecture du fichier à parser. Il reste cependant de la responsabilité de l'utilisateur que de fournir un fichier d'entree valide, correctement formaté et indexé.
=======
\section {ModÃ©lisation des objets}
Le type \textit{Objet} reprÃ©sente un rectangle Ã  placer sur la bande. 
Afin de le modÃ©liser, nous avons crÃ©Ã© un record type contenant 
les attributs suivants:
\begin{itemize}
  \item Indice : ReprÃ©sente l'indice de l'objet comme prÃ©sent dans le fichier 
    parsÃ©.
  \item Largeur : Largeur du rectangle
  \item Hauteur : Hauteur du rectangle
  \item Position : De type \textit{Point}, aussi un type record comprenant une 
    coordonnÃ©e X et une Y. 
    ReprÃ©sente la position du coin supÃ©rieur gauche du rectangle dans le graph SVG.
\end{itemize}

Comme le type \textit{Objet} est declarÃ© comme private, nous avons crÃ©Ã© tout un jeu de setters et getters pour lire ou modifier la valeur de ses attributs.
Finalement, \textit{Tableau\_Objets} est simplement un tableau non-contraint d'Ã©lÃ©ments de type Objet.

\section {Parseur}
Le fonctionnement du parseur est assez simple, \textbf{Lecture\_En\_Tete} se contente de lire les deux premiers nombres de type Natural qu'il trouve dans le fichier d'entrÃ©e. \\
La procÃ©dure \textbf{Lecture} quand Ã  elle saute les deux premiÃ¨res lignes du fichier et pour tous les objets du fichier, lit la valeur de l'indice, la largeur, et la hauteur, et les stocke dans les attributs de l'Objet correspondant dans le tableau 
d'\textit{Objet}.
\paragraph{} Dans les deux cas, nous avons fait attention Ã  bien gÃ©rer toutes les exceptions qu'il est possible de rencontrer lors de la lecture du fichier a parser. Il reste cependant de la responsabilitÃ© de l'utilisateur que de fournir un fichier d'entrÃ©e valide et correctement formatÃ© et indexÃ©.
>>>>>>> FETCH_HEAD
\newpage

\section {Mise en Oeuvre du packing}
Notre implÃ©mentation de l'algorithme \textbf{Next\_Fit\_Decreasing\_Height} est la suivante :
\begin{itemize}
<<<<<<< HEAD
  \item \underline{Tri decroissant du tableau:} Nous avons choisi d'utiliser une procedure générique, \textit{Ada.Containers.Generic\_Array\_Sort}\footnote{http://rosettacode.org/wiki/Sort\_an\_array\_of\_composite\_structures} qui une fois instanciée permet le tri d'un tableau par ordre croissant. Afin d'obtenir un tri décroissant, nous avons remplace le signe '<' de la fonction de comparaison \textbf{"<"} par son opposé, '>'.\\
\noindent Nous avons choisi cette solution car elle offre un tri rapide et concis.
  \item \underline{Positionnement des objets:} Chaque \textit{Objet} est donc doté d'un attribut \emph{Position : Point(X,Y);} qui va lui être assigné par l'algorithme de \textit{Packing}. \textit{H\_Max} est la hauteur du premier élément du niveau, \textit{H\_Cour} et \textit{L\_Cour} sont la hauteur et largeur courante permettant d'établir la position d'un objet dans l'image. \\
A la fin de l'algorithme, on obtient la hauteur totale du ruban, qui est égale a la somme des hauteurs de tous les premiers éléments de niveau.
\end{itemize}

\section {Sauvegarde SVG}
Finalement, la procedure de sauvegarde dans le fichier SVG va ouvrir ou créer le fichier dont le nom est donné en argument si celui-ci n'existe pas, puis fixer la taille de l'image SVG. Ensuite, pour tous les \textit{Objets} du tableau, il va y écrire le code de dessin d'un rectangle doté des attributs suivants:
=======
  \item \underline{Tri dÃ©croissant du tableau:} Nous avons choisi d'utiliser une procÃ©dure gÃ©nÃ©rique, \textit{Ada.Containers.Generic\_Array\_Sort}\footnote{http://rosettacode.org/wiki/Sort\_an\_array\_of\_composite\_structures} qui une fois instanciÃ©e permet le tri d'un tableau par ordre croissant. Afin d'obtenir un tri dÃ©croissant, nous avons remplacÃ© le signe '<' de la fonction de comparaison \textbf{"<"} par '>'.\\
\noindent Nous avons choisi cette solution car elle offre un tri extrÃªmement rapide et concis.
  \item \underline{Positionnement des objets:} Chaque \textit{Objet} est donc dotÃ© d'un attribut \emph{Position : Point(X,Y);} qui va Ãªtre assignÃ© par l'algorithme de packing. \textit{H\_Max} est la hauteur du premier Ã©lÃ©ment du niveau, \textit{H\_Cour} et \textit{L\_Cour} sont la hauteur et largeur courante permettant d'Ã©tablir la position d'un objet. \\
A la fin de l'algorithme, on obtient la hauteur totale du ruban qui est Ã©gale Ã  la somme de la hauteur de tous les premiers Ã©lements de niveau.
\end{itemize}

\section {Sauvegarde SVG}
Finalement, la procÃ©dure de sauvegarde dans le fichier SVG va crÃ©er le fichier dont le nom est donnÃ© en argument si il n'existe pas, puis fixer la taille de l'image SVG. Puis, pour tous les \textit{Objets} du tableau, il va y Ã©crire le code d'un rectangle avec les attributs suivants:
>>>>>>> FETCH_HEAD

\begin{framed}
\small \noindent
<rect x="\textcolor{red}{Objet.Position.X}" y="\textcolor{red}{Objet.Position.X}" \\
width="\textcolor{red}{Objet.Largeur}" height="\textcolor{red}{Objet.Hauteur}" 
        style="\textcolor{red}{rgb(Vr,Vg,Vb)};\\
        stroke-width:0;stroke:rgb(0,0,0)"/>
\end{framed}

<<<<<<< HEAD
Les rectangles sont aussi colorés de façon cyclique afin qu'il n'y ai jamais deux rectangles côte à côte remplis de la même couleur.
=======
Les rectangles sont aussi colorÃ©s de faÃ§on cyclique afin qu'il n'y ai jamais deux rectangles cÃ´te Ã  cÃ´te avec la mÃªme couleur.
>>>>>>> FETCH_HEAD

\end{document}
