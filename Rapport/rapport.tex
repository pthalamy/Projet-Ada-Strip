\documentclass{article}

\usepackage[latin1]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{graphicx}
\usepackage{listings}
\usepackage[usenames, dvipsnames]{color}
\usepackage{framed}

\title{Rapport de Projet Algo -- Strip Packing}
\author{\textsc{Benjamin Lebit} - \textsc{Pierre Thalamy}}
\date{\today}

\begin{document}

\maketitle

\section {Modélisation des objets}
Le type \textit{Objet} représente un rectangle à placer sur la bande. 
Afin de le modéliser, nous avons créé un record type contenant 
les attributs suivants:
\begin{itemize}
  \item Indice : Représente l'indice de l'objet comme présent dans le fichier 
    parsé.
  \item Largeur : Largeur du rectangle
  \item Hauteur : Hauteur du rectangle
  \item Position : De type \textit{Point}, aussi un type record comprenant une 
    coordonnée X et une Y. 
    Représente la position du coin superieur gauche du rectangle dans le graph SVG.
\end{itemize}

Comme le type \textit{Objet} est declaré comme private, nous avons créé tout un jeu de setters et getters pour lire ou modifier la valeur de ses attributs.
Finalement, \textit{Tableau\_Objets} est simplement un tableau non-contraint d'éléments de type Objet.

\section {Parseur}
Le fonctionnement du parseur est assez simple, \textbf{Lecture\_En\_Tete} se contente de lire les deux premiers nombres de type Natural qu'il trouve dans le fichier d'entrée. \\
La procédure \textbf{Lecture} quand a elle saute les deux premières lignes du fichier et pour tous les objets du fichier, lit la valeur de l'indice, la largeur, et la hauteur, et les stocke dans les attributs de l'Objet correspondant dans le tableau 
d'\textit{Objet}.
\paragraph{} Dans les deux cas, nous avons fait attention a bien gérer toutes les exceptions qu'il est possible de rencontrer lors de la lecture du fichier a parser. Il reste cependant de la responsabilité de l'utilisateur que de fournir un fichier d'entrée valide et correctement formaté et indexé.
\newpage

\section {Mise en Oeuvre du packing}
Notre implémentation de l'algorithme \textbf{Next\_Fit\_Decreasing\_Height} est la suivante :
\begin{itemize}
  \item \underline{Tri décroissant du tableau:} Nous avons choisi d'utiliser une procédure générique, \textit{Ada.Containers.Generic\_Array\_Sort}\footnote{http://rosettacode.org/wiki/Sort\_an\_array\_of\_composite\_structures} qui une fois instanciée permet le tri d'un tableau par ordre croissant. Afin d'obtenir un tri décroissant, nous avons remplace le signe '<' de la fonction de comparaison \textbf{"<"} par '>'.\\
\noindent Nous avons choisi cette solution car elle offre un tri extremement rapide et concis.
  \item \underline{Positionnement des objets:} Chaque \textit{Objet} est donc doté d'un attribut \emph{Position : Point(X,Y);} qui va être assigné par l'algorithme de packing. \textit{H\_Max} est la hauteur du premier élement du niveau, \textit{H\_Cour} et \textit{L\_Cour} sont la hauteur et largeur courante permettant d'établir la position d'un objet. \\
A la fin de l'algorithme, on obtient la hauteur totale du ruban qui est égale à la somme de la hauteur de tous les premiers élements de niveau.
\end{itemize}

\section {Sauvegarde SVG}
Finalement, la procédure de sauvegarde dans le fichier SVG va créer le fichier dont le nom est donné en argument si il n'existe pas, puis fixer la taille de l'image SVG. Puis, pour tous les \textit{Objets} du tableau, il va y écrire le code d'un rectangle avec les attributs suivants:

\begin{framed}
\small \noindent
<rect x="\textcolor{red}{Objet.Position.X}" y="\textcolor{red}{Objet.Position.X}" \\
width="\textcolor{red}{Objet.Largeur}" height="\textcolor{red}{Objet.Hauteur}" 
        style="\textcolor{red}{rgb(Vr,Vg,Vb)};\\
        stroke-width:0;stroke:rgb(0,0,0)"/>
\end{framed}

Les rectangles sont aussi colorés de façon cyclique afin qu'il n'y ai jamais deux rectangles côte à côte avec la même couleur.

\end{document}
